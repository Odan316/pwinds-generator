define([
    'require',
    'jquery',
    'lodash',
    'components/VariantEntity',
    'components/StorageLink',
    'components/Dice'
], function (require, $, _, VariantEntity, StorageLink, Dice) {
    /**
     * Base entity class, also serves as root entity class
     *
     * @constructor
     */
    var Entity = function () {
        /**
         * Entity tag, for in search via path
         *
         * @type {String|null}
         * @private
         */
        var _tag = null;

        /**
         * Entity title, for interface
         *
         * @type {String|null}
         * @private
         */
        var _title = null;

        /**
         * Entity hint, for interface. There are possibility to set fast tags, but it is in progress
         *
         * @type {String|null}
         * @private
         */
        var _hint = null;

        /**
         * Whether to hide from entities tree
         *
         * @type {boolean}
         * @private
         */
        let _hide = false;

        /**
         * Dice formula, for randomizing result from _variants
         * Has default value as d12
         *
         * @type {String|null}
         * @private
         */
        var _dice = "d12";

        /**
         * Whether to use user-provided modifier for roll
         *
         * @type {boolean}
         * @private
         */
        var _use_modifier = false;

        /**
         * Whether to use user-provided formula for roll instead of "dice" property
         *
         * @type {boolean}
         * @private
         */
        var _use_custom_dice = false;

        /**
         * Static value, entity simply returns it
         *
         * @type {String|null}
         * @private
         */
        var _static = null;

        /**
         * List of child entities, calculator rolls _dice and finds appropriate child by _min and _max
         *
         * @type {VariantEntity[]|null}
         * @private
         */
        var _variants = null;

        /**
         * List of sub-entities, used for storage linking, but not auto-generated by themselves
         * @type {VariantEntity[]|null}
         */
        var _dictionaries = null;

        /**
         * Template for generation combined entity
         *
         * @type {VariantEntity[]|null}
         * @private
         */
        var _template = null;

        /**
         * List of additional entities, calculator generates every entity from list. Each element is path to entity in tree.
         *
         * @type {VariantEntity[]|StorageLink[]|null}
         * @private
         */
        var _additional = null;

        /**
         * Number of entities to generate
         *
         * @type {null}
         * @private
         */
        var _repeat = null;

        /**
         * List of optional entities, similar to 'additional', but shows as separate block.
         *
         * @type StorageLink[]|null}
         * @private
         */
        var _optional = null;

        /**
         * Additional variables
         *
         * @type {{}}
         * @private
         */
        let _vars = {};

        /**
         * Loads JSON data in Entity object
         *
         * @param data
         * @param data.tag
         * @param data.title
         * @param data.hint
         * @param data.hide
         * @param data.dice
         * @param data.use_modifier
         * @param data.use_custom_dice
         * @param data.static
         * @param data.variants
         * @param data.dictionaries
         * @param data.additional
         * @param data.optional
         * @param data.template
         * @param data.repeat
         * @param data.vars
         */
        this.load = function (data) {
            if ("tag" in data) {
                _tag = data.tag;
            }
            if ("title" in data) {
                _title = data.title;
            }
            if ("hint" in data) {
                _hint = data.hint;
            }
            if ("hide" in data) {
                _hide = data.hide;
            }
            if ("dice" in data) {
                _dice = data.dice;
            }
            if ("use_modifier" in data) {
                _use_modifier = data.use_modifier;
            }
            if ("use_custom_dice" in data) {
                _use_custom_dice = data.use_custom_dice;
            }
            if("static" in data) {
                _static = data.static;
            }
            if ("variants" in data) {
                _variants = [];
                _.forEach(data.variants, function (value) {
                    let innerEntity = new VariantEntity();
                    innerEntity.load(value);
                    _variants.push(innerEntity);
                });
            }
            if ("dictionaries" in data) {
                _dictionaries = [];
                _.forEach(data.dictionaries, function (value) {
                    let innerEntity = new VariantEntity();
                    innerEntity.load(value);
                    _dictionaries.push(innerEntity);
                });
            }
            if ("additional" in data) {
                _additional = [];
                _.forEach(data.additional, function (value) {
                    if (_.isString(value) || _.isArray(value)) {
                        _additional.push(new StorageLink(value));
                    } else {
                        let innerEntity = new VariantEntity();
                        innerEntity.load(value);
                        _additional.push(innerEntity);
                    }
                });
            }
            if ("optional" in data) {
                _optional = [];
                _.forEach(data.optional, function (value) {
                    _optional.push(new StorageLink(value));
                });
            }
            if ("template" in data) {
                _template = [];
                _.forEach(data.template, function (value) {
                    let innerEntity = new VariantEntity();
                    innerEntity.load(value);
                    _template.push(innerEntity);
                });
            }
            if ("repeat" in data) {
                _repeat = _.toString(data.repeat);
            }
            if ("vars" in data) {
                _vars = data.vars;
            }
        };

        /**
         * Returns entity tag
         *
         * @returns {String|null}
         */
        this.getTag = function () {
            if (_tag != null) {
                return _tag;
            } else {
                return "no_tag";
            }
        };

        /**
         * Return entity title of (if it is empty) beautified tag
         *
         * @returns {String|null}
         */
        this.getTitle = function () {
            if (_title !== null) {
                return _title;
            } else {
                return this.getTag().beautifyTag();
            }
        };

        /**
         * Return hint text, if available, also convert fast hints from tag to text
         *
         * @returns {string}
         */
        this.getHint = function () {
            if (_hint === "$dice") {
                _hint = "Use 'Roll' field to enter dice formula for this entity";
            } else if (_hint === "$modifier") {
                _hint = "Use 'Mod +' field to enter dynamic modifier for this roll";
            }

            return _hint;
        };

        /**
         * Returns whether to hide entity from user
         * @returns {boolean}
         */
        this.getHide = function () {
            return _hide;
        };


        /**
         * Returns entity dice
         *
         * @returns {String|null}
         */
        this.getDice = function () {
            let dice = _dice;
            if (this.useCustomDice()) {
                let customDice = $("#diceRoller").val();
                if (!_.isEmpty(customDice)) {
                    dice = customDice;
                }
            }
            if (this.useCustomModifier()) {
                let customMod = $("#diceModifier").val();
                if (!_.isEmpty(customMod)) {
                    dice += ('+' + customMod);
                }
            }

            return dice;
        };

        /**
         * Forces use of user-provided modifier
         *
         * @returns {Boolean}
         */
        this.useCustomModifier = function () {
            return _use_modifier;
        };


        /**
         * Forces use of user-provided dice
         *
         * @returns {Boolean}
         */
        this.useCustomDice = function () {
            return _use_custom_dice;
        };

        /**
         * Transforms entity into simple array with subtree
         *
         * @returns {{text}}
         */
        this.getTreeNode = function () {
            var node = {
                tag: this.getTag(),
                title: this.getTag().beautifyTag(),
                hint: this.getHint()
            };
            var nodes = this.getSubTree();
            if (nodes.length > 0) {
                node.nodes = nodes;
            }

            return node;
        };

        /**
         * Transforms _variants entities to simple subtree
         *
         * @returns {Array}
         */
        this.getSubTree = function () {
            var subTree = [];

            _.forEach(_variants, function (entity) {
                if (!entity.getHide()) {
                    subTree.push(entity.getTreeNode());
                }
            });
            _.forEach(_dictionaries, function (entity) {
                if (!entity.getHide()) {
                    subTree.push(entity.getTreeNode());
                }
            });

            return subTree;
        };

        /**
         * Return entity by tag
         *
         * @param tag
         * @returns {Entity}
         */
        this.getChildEntityByTag = function (tag) {

            let entity = _.find(_dictionaries, function (o) {
                return o.getTag() === tag;
            });

            if (entity === undefined) {
                entity = _.find(_variants, function (o) {
                    return o.getTag() === tag;
                });
            }

            if (entity !== undefined) {
                return entity;
            } else {
                //TODO: надо обрабатывать
                console.log("Entity '" + _tag + "' | No child entity with tag '" + tag + "'");
                return null;
            }
        };

        /**
         * Return entity by roll
         *
         * @param roll
         * @returns {Entity}
         */
        this.getChildEntityByRoll = function (roll) {

            let entity = _.find(_variants, function (o) {
                return o.getMin() <= roll && o.getMax() >= roll;
            });

            // If exact variant is absent due to roll is too high - take variant with highest roll
            if(entity === undefined){
                let lastVariant = _.last(_variants);
                if(lastVariant !== undefined && roll > lastVariant.getMax()){
                    entity = lastVariant;
                }
            }

            if (entity !== undefined) {
                return entity;
            } else {
                //TODO: надо обрабатывать
                console.log("Entity '" + _tag + "' | No child entity with roll '" + roll + "'");
                return null;
            }
        };


        this.isStatic = function(){
            return _static != null;
        };

        this.getStaticValue = function(){
            return _static;
        };

        /**
         * Return true if entity has variants|childs
         * @returns {boolean}
         */
        this.hasVariants = function () {
            return _variants != null && _variants.length > 0;
        };


        /**
         * Returns true if entity has sub-entities
         * @returns {boolean}
         */
        this.hasDictionaries = function () {
            return _dictionaries != null;
        };

        /**
         * Returns list of sub-entities
         * @type {Entity[]|null}
         */
        this.getDictionaries = function () {
            return _dictionaries;
        };

        /**
         * Return true if entity has additional properties
         * @returns {boolean}
         */
        this.hasAdditional = function () {
            return _additional != null && _additional.length > 0;
        };

        /**
         * Returns array of storage links for additional entities
         * @returns {StorageLink[]|null}
         */
        this.getAdditionalEntitiesLinks = function () {
            return _additional;
        };

        /**
         * Return true if entity has optional properties
         * @returns {boolean}
         */
        this.hasOptional = function () {
            return _optional != null && _optional.length > 0;
        };

        /**
         * Returns array of storage links for optional entities
         * @returns {StorageLink[]|null}
         */
        this.getOptionalEntitiesLinks = function () {
            return _optional;
        };

        /**
         * Returns true if entity has template for combine entities to result
         * @returns {boolean}
         */
        this.hasTemplate = function () {
            return _template != null;
        };

        /**
         * Returns template for combine entities to result
         * @type {Entity[]|null}
         */
        this.getTemplate = function () {
            return _template;
        };

        /**
         * Returns formula of repeating of generating entity
         * @returns {String|Number}
         */
        this.getRepeat = function () {
            let formula = _repeat !== null ? _repeat : "1";
            let dice = new Dice();
            return dice.roll(formula);
        };

        /**
         * Returns additional variables
         * @type {Entity[]|null}
         */
        this.getVars = function () {
            return _vars;
        };
    };

    return Entity;

});